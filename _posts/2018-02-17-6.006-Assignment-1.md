---
layout: post
title: "Assignment-1"
date: 2018-02-17
categories: [6.006, computer science, assignment]
---
### Problem 1-1
* a) $$1000n < n^{0.99999}log(n) < n^{2} < 1.00001^{n}$$ - WRONG

  Answer - $$n^{0.99999}log(n) < 1000n < n^{2} < 1.00001^{n}$$


* b) $$2^{2^{1000000}} < n\sqrt{n} < {n \choose 2}  < 2^{100000n}$$


* c)  $$\sum_{i=1}^{n}(i+1) < 2^{n} < n^{\sqrt{n}} <  n^{10}.2^{\frac{n}{2}}$$ - WRONG

  Answer - $$\sum_{i=1}^{n}(i+1)< n^{\sqrt{n}} <  n^{10}.2^{\frac{n}{2}} < 2^{n} $$ 




### Problem 1.2
a) 
$$T(n,n)=\Theta(2n)+T(n/2, n/2)=\Theta(2n)+\Theta(n)+T(n/4,n/4)$$
Expanding in this manner,
$$T(n,n)=\Theta(2n+n+n/2+n/4+ \dots)=\Theta(n[2 + 1 + (1/2+1/4+1/8+\dots)]) = \Theta(n[2+1+1])= \Theta(4n)$$

Ignoring the constant 4, answer is option (2)  $$\Theta(n)$$

b)
$$T(n,n)=\Theta(n)+T(n, n/2)=\Theta(n)+\Theta(n)+T(n, n/4)$$

For $$y=n$$ to reach $$y\leq 2$$ while dividing by $$2$$ in each step will take $$log_{2}(n)$$ steps. So,

$$T(n,n) = \Theta(n+n+n+\dots)  = \Theta(n \times log_{2}(n))$$

 Answer is option (3) $$\Theta(n \times log_{2}(n))$$.

c) 
$$T(n,n)=\Theta(n)+S(n,n/2) =\Theta(n)+\Theta(n/2)+T(n/2,n/2) =\Theta(n)+\Theta(n/2) + \Theta(n/2)+S(n/2,n/4)$$

Expanding as above,

$$T(n,n)=\Theta(n)+ 2 \times [\Theta(n/2) + \Theta(n/4) + \dots] + \Theta(1) \\= \Theta(n) + 2 \times \Theta(n) + \Theta(1) =  \Theta(3n + 1)$$

Ignoring the constants 3 and 1, the answer is option (2) $$\Theta(n)$$

### Problem 1.3
a) Yes
b) Yes
c) Yes - WRONG, Answer - No
d) Yes

### Problem 1.4
a) It takes $$n$$ steps to scan a particular column. In the worst case we will have to scan $$log_{2}n$$ columns. So the total complexity is $$\Theta(n.log_{2}(n))$$. 

Answer : (3)

b) In the worst case, we may have to search every alternate row or column. So the total complexity is $$\Theta(n^{2})$$.

Answer : (5)

c) Since the row seperated subprolems are first in the list they will always be picked. But for each subsequent subproblem, the number of rows to be searched is halved, whereas the number of coulmns remain the same.

* Total number of row to be searched = $$n.log_{2}(n)$$

* Total number of columns to be searched = $$n+n/2+n/4+\dots=2n$$

* Total complexity = $$2n+n.log_{2}(n)$$

Answer : (3)

d) In this algorithm, the rows and columns are alternatively chosen to be searched.

* Total number of searches in row or column = $$n+n/2+n/2+n/4+n/4+\dots=n+n+n=3n$$

  Answer : (2)  $$\Theta(n)$$

### Problem 1.5

The most efficient algorithm is Algorithm 4.

1) **If the peak problem is not empty, the algorithm 4 will return a location.**

The size of the recursive subproblem for a problem of size $$m\times n$$ could be 

* $$\lfloor m/2 \rfloor \times n$$ or

* $$(m - \lfloor m/2 \rfloor - 1) \times n$$ or 

* $$m \times \lfloor n/2 \rfloor$$ or

* $$m \times (n - \lfloor n/2 \rfloor - 1)$$. 

The size of the problem is strictly decreasing with each recursion. When one of the dimensions become 0 we consider the problem empty. So if the recursion continues without finding a peak, it will eventually reach an empty problem.

But before reaching an empty problem, it would have to pass through a subproblem whose $$m=2$$, $$m=1$$, $$n=2$$ or $$n=1$$. In that subproblem, if the dimension is 1, then finding the peak is just finding the maximum of that row or column. If the dimension is 2, then finding the peak is finding the maximum of that row or column, or finding a neighbor who has a higher value, in which case the next step would be to narrow the problem down to that neighboring row or column.

So we are assured that a non-empty problem will return a location as its peak.

2) **If algorithm 4 returns a location, it will be a peak in the original problem**

If algorithm 4 returns a location $$l_p=(r_1, c_1)$$ it should be the best value in either row $$r_1$$ or column $$c_1$$. So it is a peak in some recursive subproblem.  So if $$l_p$$ is in fact not a peak, there must be a bigger problem in which $$l_p$$ ceases to become a peak. 

Consider that $$l_p$$ is not a peak because of it's adjacency to $$l_q$$ s.t $$val(l_q) > val(l_p)$$. $$l_q$$ must have been on the dividing row or column $$D$$ for it to be part of the bigger problem but not part of the smaller subproblem. 

Since $$l_q$$ was examined during recursion, it must have been the BestSeen value. If it wasn't, then $$val(l_p) > val(l_q)$$. This is a contradiction.

### Problem 1.6 

For Algorithm 3, 
$$
P = 
\begin{bmatrix}
    0 & 0 & 5 & 4 &  0 & 0 & 0 \\
    0 & 0 & 0 & 0 &  0 & 0 & 0  \\
    0 & 2 & 0 & 0 &  0 & 0 & 0 \\
    0 & 3 & 0 & 0 &  0 & 0 & 0 \\
    0 & 0 & 0 & 0 &  0 & 0 & 0 \\
    0 & 0 & 0 & 0 &  0 & 0 & 0 \\
    0 & 0 & 0 & 0 &  0 & 0 & 0 \\
\end{bmatrix}
$$
will return the location $$(2,1)$$ with value 2, even though location $$(3,1)$$ with value 3 is a neighbor.
